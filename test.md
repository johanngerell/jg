---


---

<hr>
<h2 id="title-c-codegen-differences-between-msvc-clang-and-gccpublished-falsedescription-c-codegen-differences-between-msvc-clang-and-gcctags-cpp-compiler-optimization-assemblycover_image-httpsdirect_url_to_image.jpg">title: C++ Codegen Differences Between MSVC, Clang and GCC<br>
published: false<br>
description: C++ Codegen Differences Between MSVC, Clang and GCC<br>
tags: cpp, compiler, optimization, assembly<br>
//cover_image: https://direct_url_to_image.jpg</h2>
<p><strong>NOTE!</strong> The lack of parameter checking and error handling in example code snippets is intentional, for the sake of brevity and readability.</p>
<h2 id="assembly-crash-course">Assembly Crash Course</h2>
<ul>
<li><a href="#simple-example">Simple Example</a>
<ul>
<li><a href="#msvc-codegen">MSVC Codegen</a></li>
<li><a href="#clang-codegen">Clang Codegen</a></li>
<li><a href="#gcc-codegen">GCC Codegen</a></li>
<li><a href="#conclusions">Conclusions</a></li>
</ul>
</li>
<li><a href="#function-parameter-passing">Function Parameter Passing</a>
<ul>
<li><a href="#special-c-parameters">Special C++ Parameters</a></li>
</ul>
</li>
<li><a href="#example-2-class-with-member-function-and-data">Example 2: Class With Member Function and Data</a>
<ul>
<li><a href="#example-2-msvc-codegen">Example 2: MSVC Codegen</a></li>
</ul>
</li>
</ul>
<h3 id="simple-example">Simple Example</h3>
<p>Let’s say that we have a helper function <code>random_int()</code> that generates a pseudo-random 32-bit integer in the range [0, <code>max_value</code>):</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">random_int</span><span class="token punctuation">(</span><span class="token keyword">int</span> max_value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> max_value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>If this simple wrapper function is compiled with speed optimizations enabled for the latest releases of the MSVC, Clang and GCC compilers, then it turns out that almost identical assembly code is generated by all of them: <a href="https://godbolt.org/z/TfdrfvqMa">Compiler Explorer - Simple Example</a>.</p>
<p>I’ve annotated the three assembly listings from that “Godbolt” in the following sections.</p>
<h4 id="msvc-codegen">MSVC Codegen</h4>

<table>
<thead>
<tr>
<th>Compiler</th>
<th>Options</th>
</tr>
</thead>
<tbody>
<tr>
<td>x64 msvc v19.28 (VS16.9)</td>
<td>/O2 /std:c++17</td>
</tr>
</tbody>
</table><pre class=" language-nasm"><code class="prism  language-nasm">push    <span class="token register variable">rbx</span>       <span class="token comment">; save old rbx on the stack since it's</span>
                  <span class="token comment">; nonvolatile and we'll use it below</span>
sub     <span class="token register variable">rsp</span>, <span class="token number">32</span>   <span class="token comment">; increase stack by 32 bytes - the size</span>
                  <span class="token comment">; required to save all 4 parameter</span>
                  <span class="token comment">; registers, the "shadow space"</span>
mov     <span class="token register variable">ebx</span>, <span class="token register variable">ecx</span>  <span class="token comment">; save ecx (max_value) in ebx - rand()</span>
                  <span class="token comment">; might overwrite it</span>
call    rand      <span class="token comment">; rand() returns a random value between 0</span>
                  <span class="token comment">; and RAND_MAX in eax</span>
cdq               <span class="token comment">; prepares edx for the division below</span>
idiv    <span class="token register variable">ebx</span>       <span class="token comment">; the integer division quotient of eax</span>
                  <span class="token comment">; (the random value) divided by ebx</span>
                  <span class="token comment">; (max_value) is stored in eax and the</span>
                  <span class="token comment">; remainder (the random value modulo</span>
                  <span class="token comment">; max_value) in edx</span>
mov     <span class="token register variable">eax</span>, <span class="token register variable">edx</span>  <span class="token comment">; store the return value in eax</span>
add     <span class="token register variable">rsp</span>, <span class="token number">32</span>   <span class="token comment">; reset the stack size</span>
pop     <span class="token register variable">rbx</span>       <span class="token comment">; restore rbx from the stack</span>
ret     <span class="token number">0</span>         <span class="token comment">; return to the caller and continue</span>
                  <span class="token comment">; execution on the instruction after the</span>
                  <span class="token comment">; call</span>
</code></pre>
<p>The annotations in the assembly above are also applicable to the following two listings for <a href="#clang-codegen">Clang</a> and <a href="#gcc-codegen">GCC</a>.</p>
<h4 id="clang-codegen">Clang Codegen</h4>

<table>
<thead>
<tr>
<th>Compiler</th>
<th>Options</th>
</tr>
</thead>
<tbody>
<tr>
<td>x86-64 clang 11.0.1</td>
<td>-O3 -std=c++17</td>
</tr>
</tbody>
</table><pre class=" language-nasm"><code class="prism  language-nasm">push    <span class="token register variable">rbx</span>
mov     <span class="token register variable">ebx</span>, <span class="token register variable">edi</span>
call    rand
cdq
idiv    <span class="token register variable">ebx</span>
mov     <span class="token register variable">eax</span>, <span class="token register variable">edx</span>
pop     <span class="token register variable">rbx</span>
ret
</code></pre>
<p>This codegen is identical to MSVC’s, with the exception that the <code>max_value</code> parameter is passed in <code>rdi</code> instead of <code>rcx</code>, and that no parameter “shadow space” is set up.</p>
<h4 id="gcc-codegen">GCC Codegen</h4>

<table>
<thead>
<tr>
<th>Compiler</th>
<th>Options</th>
</tr>
</thead>
<tbody>
<tr>
<td>x86-64 gcc 10.2</td>
<td>-O3 -std=c++17</td>
</tr>
</tbody>
</table><pre class=" language-nasm"><code class="prism  language-nasm">push    <span class="token register variable">rbx</span>
mov     <span class="token register variable">ebx</span>, <span class="token register variable">edi</span>
call    rand
cdq
idiv    <span class="token register variable">ebx</span>
pop     <span class="token register variable">rbx</span>
mov     <span class="token register variable">eax</span>, <span class="token register variable">edx</span>
ret
</code></pre>
<p>This codegen is identical to Clang’s, with the exception that the second and third last operations (<code>pop</code> and <code>mov</code>) are done in the opposite order.</p>
<h4 id="conclusions">Conclusions</h4>
<p>In conclusion, for the particular function <code>random_int()</code> used in this example, the two major differences between the code generation of the three compared compilers are:</p>
<ul>
<li>
<p>MSVC uses “shadow space” on the stack for saving of parameters passed in registers - Clang and GCC don’t.</p>
</li>
<li>
<p>MSVC passes parameters in different registers than Clang and GCC do. This will be looked at in more detail in the next section.</p>
</li>
</ul>
<h3 id="function-parameter-passing">Function Parameter Passing</h3>
<p>MSVC passes parameters to a function in a way that differs from how Clang and GCC do it. This is how they do it for the simplest scenario with only integer-style parameters (size and sign can vary):</p>
<ul>
<li>
<p>MSVC passes the first four parameters using registers <code>rcx</code>, <code>rdx</code>, <code>r8</code> and <code>r9</code>, in that order. Any additional parameters are pushed on the stack.</p>
</li>
<li>
<p>Clang and GCC pass the first six parameters using registers <code>rdi</code>, <code>rsi</code>, <code>rcx</code>, <code>rdx</code>, <code>r8</code> and <code>r9</code>, in that order. Any additional parameters are pushed on the stack.</p>
</li>
</ul>
<p>We saw an example of this parameter passing difference in the assembly listings of <a href="#simple-example">Simple Example</a>, where MSVC saved the <code>max_value</code> parameter that was passed in the <code>rcx</code> register, while Clang and GCC saved the <code>rdi</code> register.</p>
<h4 id="special-c-parameters">Special C++ Parameters</h4>
<p>In addition to the above mentioned difference in what registers the different compilers use to pass function parameters, a couple of C++ specific differences apply.</p>
<h5 id="member-functions">Member Functions</h5>
<p>When a non-static class or struct member function is called, the <code>this</code> pointer of the specific instance that the function is called for must be passed to the function:</p>
<ul>
<li>
<p>MSVC passes <code>this</code> as a “hidden” first parameter in the <code>rcx</code> register.</p>
</li>
<li>
<p>Clang and GCC pass <code>this</code> as a “hidden” first parameter in the <code>rdi</code> register, unless the function has a copy elided return value (see Clang and GCC in <a href="#copy-elided-return-values">Copy Elided Return Values</a>).</p>
</li>
</ul>
<p>This means that member functions have one or two less free registers to use for its parameters.</p>
<h5 id="copy-elided-return-values">Copy Elided Return Values</h5>
<p>Through the mandatory <em>copy elision</em> introduced in C++17, or the earlier optional <em>NRVO</em> (named return value optimization), or <em>RVO</em> (return value optimization), functions that return values can elide copying or moving those values to the caller.</p>
<p>This is done by having the caller allocate memory for the return value before calling the function, and then letting the function create the value directly in that memory:</p>
<ul>
<li>
<p>MSVC passes the memory address for the return value as a “hidden” first parameter in the <code>rcx</code> register, unless the called function is a non-static member function, in which case it’s the second parameter in the <code>rdx</code> register (see MSVC in <a href="#member-functions">Member Functions</a>).</p>
</li>
<li>
<p>Clang and GCC pass the memory address for the return value as a “hidden” first parameter in the <code>rdi</code> register. If the called function is a non-static member function, the instance <code>this</code> pointer is passed as the second parameter in the <code>rsi</code> register.</p>
</li>
</ul>
<p>This means that functions with copy elided return values have one or two less free registers to use for its parameters.</p>
<h3 id="example-2-class-with-member-function-and-data">Example 2: Class With Member Function and Data</h3>
<p>In this example we look at the codegen for a non-static class (or struct) member function that uses non-static instance data. We will see how the <code>this</code> pointer to the class instance gets passed to the member function (see <a href="#member-functions">Member Functions</a>) and how the function accesses the instance data.</p>
<p>We’ll be using this somewhat contrived class, which is just a variation on the helper function used in <a href="#simple-example">Simple Example</a>:</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">struct</span> random_gen
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> unused1<span class="token punctuation">;</span>
    <span class="token keyword">int</span> unused2<span class="token punctuation">;</span>
    <span class="token keyword">int</span> max_value<span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">random_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> max_value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>The <code>unused1</code> and <code>unused2</code> members are only there to show how <code>max_value</code> gets accessed in assembly when it’s not the first member in the class.</p>
<p>The helper class <code>random_gen</code> will be used like this:</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">int</span> <span class="token function">random_user</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    random_gen gen<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4711</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">random_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Again, “Godbolting” this simple example will give very similar output for all three compared compilers:<br>
<a href="https://godbolt.org/z/8f3qWEzn5">Compiler Explorer - Class With Member Function and Data</a></p>
<p>I’ve annotated the assembly listing for MSVC in the following section. The codegen for Clang and GCC is so similar to MSVC’s that annotating them can be left as an exercise to the reader :).</p>
<h4 id="example-2-msvc-codegen">Example 2: MSVC Codegen</h4>
<p>First, the <em>callee</em></p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">int</span> random_gen<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">random_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> max_value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>for which the assembly is</p>
<pre class=" language-nasm"><code class="prism  language-nasm">push    <span class="token register variable">rbx</span>       <span class="token comment">; save old rbx on the stack since it's</span>
                  <span class="token comment">; nonvolatile and we'll use it below</span>
sub     <span class="token register variable">rsp</span>, <span class="token number">32</span>   <span class="token comment">; increase stack by 32 bytes - the size</span>
                  <span class="token comment">; required to save all 4 parameter</span>
                  <span class="token comment">; registers, the "shadow space"</span>
mov     <span class="token register variable">rbx</span>, <span class="token register variable">rcx</span>  <span class="token comment">; save the 'this' pointer in ebx - rand()</span>
                  <span class="token comment">; might overwrite rcx</span>
call    rand      <span class="token comment">; rand() returns a random value between 0</span>
                  <span class="token comment">; and RAND_MAX in eax</span>
cdq               <span class="token comment">; prepares edx for the division below</span>
idiv    DWORD PTR <span class="token operator">[</span><span class="token register variable">rbx</span><span class="token operator">+</span><span class="token number">8</span><span class="token operator">]</span> <span class="token comment">; the integer division quotient </span>
                  <span class="token comment">; of eax (the random value) divided by </span>
                  <span class="token comment">; max_value (at offset 8 from where </span>
                  <span class="token comment">; 'this' points at) is stored in eax and </span>
                  <span class="token comment">; the remainder (the random value modulo</span>
                  <span class="token comment">; max_value) in edx</span>
mov     <span class="token register variable">eax</span>, <span class="token register variable">edx</span>  <span class="token comment">; store the return value in eax</span>
add     <span class="token register variable">rsp</span>, <span class="token number">32</span>   <span class="token comment">; reset the stack size</span>
pop     <span class="token register variable">rbx</span>       <span class="token comment">; restore rbx from the stack</span>
ret     <span class="token number">0</span>         <span class="token comment">; return to the caller and continue</span>
                  <span class="token comment">; execution on the instruction after the</span>
                  <span class="token comment">; call</span>
</code></pre>
<p>Second, the <em>caller</em></p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">int</span> <span class="token function">random_user</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    random_gen gen<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4711</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">random_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>for which the assembly is</p>
<pre class=" language-nasm"><code class="prism  language-nasm">sub     <span class="token register variable">rsp</span>, <span class="token number">56</span>   <span class="token comment">; increase the stack size by the </span>
                  <span class="token comment">; required 32 bytes for "shadow </span>
                  <span class="token comment">; space", 12 bytes for the three 32-bit </span>
                  <span class="token comment">; integers in gen, and another 12 bytes</span>
                  <span class="token comment">; to make the stack address "16-byte </span>
                  <span class="token comment">; aligned"</span>
xor     <span class="token register variable">eax</span>, <span class="token register variable">eax</span>  <span class="token comment">; conventional trick to zero eax (and rax)</span>
mov     DWORD PTR gen<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token number">8</span><span class="token operator">]</span>, <span class="token number">4711</span> <span class="token comment">; the gen instance </span>
                  <span class="token comment">; memory is put at the top of the stack, </span>
                  <span class="token comment">; at the address pointed to by rsp, so</span>
                  <span class="token comment">; rsp+8 points at the `max_value` member, </span>
                  <span class="token comment">; which is set to 4711</span>
lea     <span class="token register variable">rcx</span>, QWORD PTR gen<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">]</span> <span class="token comment">; put the address of gen</span>
                  <span class="token comment">; in rcx - the hidden `this` parameter</span>
                  <span class="token comment">; to random_int</span>
mov     QWORD PTR gen<span class="token operator">$</span><span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">]</span>, <span class="token register variable">rax</span> <span class="token comment">; rsp points at the top of </span>
                  <span class="token comment">; the stack where the two 32-bit integer </span>
                  <span class="token comment">; members unused1 and unused2 are placed.</span>
                  <span class="token comment">; treat them as one 64-bit integer and </span>
                  <span class="token comment">; assign rax (which is zero) to it</span>
call    random_gen::random_int <span class="token comment">; random_int puts its return </span>
                  <span class="token comment">; value in eax, so random_user just </span>
                  <span class="token comment">; leaves it there as *its* return value </span>
                  <span class="token comment">; too</span>
add     <span class="token register variable">rsp</span>, <span class="token number">56</span>   <span class="token comment">; reset the stack size</span>
ret     <span class="token number">0</span>         <span class="token comment">; continue execution on the instruction </span>
                  <span class="token comment">; after the call to random_user</span>
</code></pre>
<p>The core of this example is that <code>gen</code> (the <code>random_gen</code> instance) is laid out in memory in the stack frame of <code>random_user</code> (the caller) and the address of that memory is passed to <code>random_gen::random_int</code> (the callee) so that it can access the member data of <code>gen</code>.</p>

<table>
<thead>
<tr>
<th>address</th>
<th>data</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>stack top - 56</td>
<td></td>
<td>44 bytes “shadow space” and alignment</td>
</tr>
<tr>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>stack top - 8</td>
<td>4711</td>
<td>gen.max_value</td>
</tr>
<tr>
<td>stack top - 4</td>
<td>0</td>
<td>gen.unused2</td>
</tr>
<tr>
<td>stack top</td>
<td>0</td>
<td>gen.unused1</td>
</tr>
</tbody>
</table><p>The stack grows “downwards” (towards lower memory addresses).</p>
<p>The effect of <code>push 'dword value'</code> is <code>sub rsp, sizeof dword</code> followed by <code>mov dword [rsp], 'dword value'</code>.</p>
<p>The effect of <code>call foo</code> is <code>push eip</code> followed by <code>jmp foo</code>.</p>

