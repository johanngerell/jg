---
title: C++ Codegen Differences Between MSVC, Clang and GCC
published: false
description: C++ Codegen Differences Between MSVC, Clang and GCC
tags: cpp, compiler, optimization, assembly
//cover_image: https://direct_url_to_image.jpg
---

# Foobar

**NOTE!** The lack of parameter checking and error handling in example code snippets is intentional, for the sake of brevity and readability.

## Assembly Crash Course

 * [Simple Example](#simple-example)
   - [MSVC Codegen](#msvc-codegen)
   - [Clang Codegen](#clang-codegen)
   - [GCC Codegen](#gcc-codegen)
   - [Conclusions](#conclusions)
 * [Function Parameter Passing](#function-parameter-passing)
   - [Special C++ Parameters](#special-c-parameters)
 * [Example 2: Class With Member Function and Data](#example-2-class-with-member-function-and-data)
   - [Example 2: MSVC Codegen](#example-2-msvc-codegen)

### Simple Example

Let's say that we have a helper function `random_int()` that generates a pseudo-random 32-bit integer in the range \[0, `max_value`):
```c++
static int random_int(int max_value)
{
    return rand() % max_value;
}
```
If this simple wrapper function is compiled with speed optimizations enabled for the latest releases of the MSVC, Clang and GCC compilers, then it turns out that almost identical assembly code is generated by all of them: [Compiler Explorer - Simple Example](https://godbolt.org/z/TfdrfvqMa).

I've annotated the three assembly listings from that "Godbolt" in the following sections.

#### MSVC Codegen

| Compiler                 | Options        |
|--------------------------|----------------|
| x64 msvc v19.28 (VS16.9) | /O2 /std:c++17 |

```nasm
push    rbx       ; save old rbx on the stack since it's
                  ; nonvolatile and we'll use it below
sub     rsp, 32   ; increase stack by 32 bytes - the size
                  ; required to save all 4 parameter
                  ; registers, the "shadow space"
mov     ebx, ecx  ; save ecx (max_value) in ebx - rand()
                  ; might overwrite it
call    rand      ; rand() returns a random value between 0
                  ; and RAND_MAX in eax
cdq               ; prepares edx for the division below
idiv    ebx       ; the integer division quotient of eax
                  ; (the random value) divided by ebx
                  ; (max_value) is stored in eax and the
                  ; remainder (the random value modulo
                  ; max_value) in edx
mov     eax, edx  ; store the return value in eax
add     rsp, 32   ; reset the stack size
pop     rbx       ; restore rbx from the stack
ret     0         ; return to the caller and continue
                  ; execution on the instruction after the
                  ; call
```
The annotations in the assembly above are also applicable to the following two listings for [Clang](#clang-codegen) and [GCC](#gcc-codegen).

#### Clang Codegen

| Compiler            | Options        |
|---------------------|----------------|
| x86-64 clang 11.0.1 | -O3 -std=c++17 |

```nasm
push    rbx
mov     ebx, edi
call    rand
cdq
idiv    ebx
mov     eax, edx
pop     rbx
ret
```
This codegen is identical to MSVC's, with the exception that the `max_value` parameter is passed in `rdi` instead of `rcx`, and that no parameter "shadow space" is set up.

#### GCC Codegen

| Compiler        | Options        |
|-----------------|----------------|
| x86-64 gcc 10.2 | -O3 -std=c++17 |

```nasm
push    rbx
mov     ebx, edi
call    rand
cdq
idiv    ebx
pop     rbx
mov     eax, edx
ret
```
This codegen is identical to Clang's, with the exception that the second and third last operations (`pop` and `mov`) are done in the opposite order.

#### Conclusions

In conclusion, for the particular function `random_int()` used in this example, the two major differences between the code generation of the three compared compilers are:

 * MSVC uses "shadow space" on the stack for saving of parameters passed in registers - Clang and GCC don't.

 * MSVC passes parameters in different registers than Clang and GCC do. This will be looked at in more detail in the next section.

### Function Parameter Passing

MSVC passes parameters to a function in a way that differs from how Clang and GCC do it. This is how they do it for the simplest scenario with only integer-style parameters (size and sign can vary):

 * MSVC passes the first four parameters using registers `rcx`, `rdx`, `r8` and `r9`, in that order. Any additional parameters are pushed on the stack.

 * Clang and GCC pass the first six parameters using registers `rdi`, `rsi`, `rcx`, `rdx`, `r8` and `r9`, in that order. Any additional parameters are pushed on the stack.

We saw an example of this parameter passing difference in the assembly listings of [Simple Example](#simple-example), where MSVC saved the `max_value` parameter that was passed in the `rcx` register, while Clang and GCC saved the `rdi` register.

#### Special C++ Parameters

In addition to the above mentioned difference in what registers the different compilers use to pass function parameters, a couple of C++ specific differences apply.

##### Member Functions

When a non-static class or struct member function is called, the `this` pointer of the specific instance that the function is called for must be passed to the function:

 * MSVC passes `this` as a "hidden" first parameter in the `rcx` register.

 * Clang and GCC pass `this` as a "hidden" first parameter in the `rdi` register, unless the function has a copy elided return value (see Clang and GCC in [Copy Elided Return Values](#copy-elided-return-values)).

This means that member functions have one or two less free registers to use for its parameters.

##### Copy Elided Return Values

Through the mandatory *copy elision* introduced in C++17, or the earlier optional *NRVO* (named return value optimization), or *RVO* (return value optimization), functions that return values can elide copying or moving those values to the caller.

This is done by having the caller allocate memory for the return value before calling the function, and then letting the function create the value directly in that memory:

 * MSVC passes the memory address for the return value as a "hidden" first parameter in the `rcx` register, unless the called function is a non-static member function, in which case it's the second parameter in the `rdx` register (see MSVC in [Member Functions](#member-functions)).

 * Clang and GCC pass the memory address for the return value as a "hidden" first parameter in the `rdi` register. If the called function is a non-static member function, the instance `this` pointer is passed as the second parameter in the `rsi` register.

This means that functions with copy elided return values have one or two less free registers to use for its parameters.

### Example 2: Class With Member Function and Data

In this example we look at the codegen for a non-static class (or struct) member function that uses non-static instance data. We will see how the `this` pointer to the class instance gets passed to the member function (see [Member Functions](#member-functions)) and how the function accesses the instance data.

We'll be using this somewhat contrived class, which is just a variation on the helper function used in [Simple Example](#simple-example):
```c++
struct random_gen
{
    int unused1;
    int unused2;
    int max_value;

    int random_int() const
    {
        return rand() % max_value;
    }
};
```
The `unused1` and `unused2` members are only there to show how `max_value` gets accessed in assembly when it's not the first member in the class.

The helper class `random_gen` will be used like this:
```c++
int random_user()
{
    random_gen gen{0, 0, 4711};
    return gen.random_int();
}
```

Again, "Godbolting" this simple example will give very similar output for all three compared compilers: [Compiler Explorer - Class With Member Function and Data](https://godbolt.org/z/8f3qWEzn5)

I've annotated the assembly listing for MSVC in the following section. The codegen for Clang and GCC is so similar to MSVC's that annotating them can be left as an exercise to the reader :).

#### Example 2: MSVC Codegen

First, the _callee_
```c++
int random_gen::random_int() const
{
    return rand() % max_value;
}
```
for which the assembly is
```nasm
push    rbx       ; save old rbx on the stack since it's
                  ; nonvolatile and we'll use it below
sub     rsp, 32   ; increase stack by 32 bytes - the size
                  ; required to save all 4 parameter
                  ; registers, the "shadow space"
mov     rbx, rcx  ; save the 'this' pointer in ebx - rand()
                  ; might overwrite rcx
call    rand      ; rand() returns a random value between 0
                  ; and RAND_MAX in eax
cdq               ; prepares edx for the division below
idiv    DWORD PTR [rbx+8] ; the integer division quotient
                  ; of eax (the random value) divided by
                  ; max_value (at offset 8 from where
                  ; 'this' points at) is stored in eax and
                  ; the remainder (the random value modulo
                  ; max_value) in edx
mov     eax, edx  ; store the return value in eax
add     rsp, 32   ; reset the stack size
pop     rbx       ; restore rbx from the stack
ret     0         ; return to the caller and continue
                  ; execution on the instruction after the
                  ; call
```
Second, the _caller_
```c++
int random_user()
{
    random_gen gen{0, 0, 4711};
    return gen.random_int();
}
```
for which the assembly is
```nasm
sub     rsp, 56   ; increase the stack size by the
                  ; required 32 bytes for "shadow
                  ; space", 12 bytes for the three 32-bit
                  ; integers in gen, and another 12 bytes
                  ; to make the stack address "16-byte
                  ; aligned"
xor     eax, eax  ; conventional trick to zero eax (and rax)
mov     DWORD PTR gen$[rsp+8], 4711 ; the gen instance
                  ; memory is put at the top of the stack,
                  ; at the address pointed to by rsp, so
                  ; rsp+8 points at the `max_value` member,
                  ; which is set to 4711
lea     rcx, QWORD PTR gen$[rsp] ; put the address of gen
                  ; in rcx - the hidden `this` parameter
                  ; to random_int
mov     QWORD PTR gen$[rsp], rax ; rsp points at the top of
                  ; the stack where the two 32-bit integer
                  ; members unused1 and unused2 are placed.
                  ; treat them as one 64-bit integer and
                  ; assign rax (which is zero) to it
call    random_gen::random_int ; random_int puts its return
                  ; value in eax, so random_user just
                  ; leaves it there as *its* return value
                  ; too
add     rsp, 56   ; reset the stack size
ret     0         ; continue execution on the instruction
                  ; after the call to random_user
```
The core of this example is that `gen` (the `random_gen` instance) is laid out in memory in the stack frame of `random_user` (the caller) and the address of that memory is passed to `random_gen::random_int` (the callee) so that it can access the member data of `gen`.

 address       | data | description
---------------|------|------
stack top - 56 |      | 44 bytes "shadow space" and alignment
.              | .    | .
stack top - 8  | 4711 | gen.max_value
stack top - 4  |    0 | gen.unused2
stack top      |    0 | gen.unused1

The stack grows "downwards" (towards lower memory addresses).

The effect of `push 'dword value'` is `sub rsp, sizeof dword` followed by `mov dword [rsp], 'dword value'`.

The effect of `call foo` is `push eip` followed by `jmp foo`.